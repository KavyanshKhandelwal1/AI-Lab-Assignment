import numpy as np
import matplotlib.pyplot as plt
import os
from fpdf import FPDF

# Create results folder
os.makedirs("lab6_results", exist_ok=True)

class HopfieldNetwork:
    def __init__(self, n_neurons):
        self.n = n_neurons
        self.W = np.zeros((n_neurons, n_neurons))
    
    def train_patterns(self, patterns):
        """Hebbian learning rule"""
        self.W = np.zeros((self.n, self.n))
        for p in patterns:
            p = p.reshape(-1, 1)
            self.W += np.dot(p, p.T)
        np.fill_diagonal(self.W, 0)
        self.W /= self.n
    
    def recall(self, pattern, steps=20):
        """Asynchronous recall updates"""
        s = pattern.copy()
        energy = []
        for _ in range(steps):
            for i in range(self.n):
                h = np.dot(self.W[i], s)
                s[i] = 1 if h >= 0 else -1
            e = -0.5 * np.dot(s.T, np.dot(self.W, s))
            energy.append(e)
        return s, energy

def random_patterns(n, p):
    """Generate p random bipolar patterns"""
    return [np.random.choice([-1, 1], size=n) for _ in range(p)]

def run_error_correction():
    N = 100
    hop = HopfieldNetwork(N)
    patterns = random_patterns(N, 5)
    hop.train_patterns(patterns)

    pattern = patterns[0]
    corrupted = pattern.copy()
    flip_fraction = 0.25
    flip_indices = np.random.choice(N, int(N*flip_fraction), replace=False)
    corrupted[flip_indices] *= -1

    recalled, energy = hop.recall(corrupted, steps=20)
    acc = np.sum(recalled == pattern) / N

    plt.figure()
    plt.plot(energy, marker='o')
    plt.title("Energy Convergence - Hopfield Error Correction")
    plt.xlabel("Iteration")
    plt.ylabel("Energy")
    plt.grid(True)
    plt.savefig("lab6_results/Q1_energy.png")
    plt.close()

    return acc, flip_fraction

# ------------------------------------------------
# Q2: Eight-Rook Problem using Hopfield Network
# ------------------------------------------------
def run_eight_rook():
    N = 8
    neurons = N * N
    A, B = 4, 4
    W = np.zeros((neurons, neurons))
    theta = np.zeros(neurons)

    def index(i, j): return i * N + j

    # Construct weights for constraints
    for i in range(N):
        for j in range(N):
            idx = index(i, j)
            for k in range(N):
                if k != j:
                    W[idx, index(i, k)] -= A
                if k != i:
                    W[idx, index(k, j)] -= B
            theta[idx] = -(A + B)

    v = np.random.choice([0, 1], size=neurons)
    energy = []

    for _ in range(400):
        i = np.random.randint(0, neurons)
        h = np.dot(W[i], v) - theta[i]
        v[i] = 1 if h > 0 else 0
        e = -0.5 * np.dot(v.T, np.dot(W, v)) + np.dot(theta, v)
        energy.append(e)

    board = v.reshape((N, N))

    plt.figure(figsize=(6, 3))
    plt.subplot(1, 2, 1)
    plt.plot(energy)
    plt.title("Energy Convergence - Eight Rook Problem")
    plt.xlabel("Iteration")
    plt.ylabel("Energy")
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.imshow(board, cmap='gray_r')
    plt.title("Final 8-Rook Board")
    plt.tight_layout()
    plt.savefig("lab6_results/Q2_rook.png")
    plt.close()

    return board

# ------------------------------------------------
# Q3: TSP with 10 Cities using Hopfield-Tank Model
# ------------------------------------------------
def run_tsp(num_cities=10, iterations=3000, A=500, B=500, C=200):
    np.random.seed(0)
    D = np.random.randint(10, 100, (num_cities, num_cities))
    np.fill_diagonal(D, 0)
    D = (D + D.T) / 2

    V = np.random.rand(num_cities, num_cities)

    def sigmoid(x, lam=1):
        # Prevent overflow
        x = np.clip(x, -100, 100)
        return 1 / (1 + np.exp(-lam * x))

    energy = []
    for step in range(iterations):
        dV = np.zeros_like(V)
        for i in range(num_cities):
            for p in range(num_cities):
                term1 = A * (np.sum(V[i, :]) - 1)
                term2 = B * (np.sum(V[:, p]) - 1)
                term3 = sum(D[i, j] * (V[j, (p+1) % num_cities] + V[j, (p-1) % num_cities])
                            for j in range(num_cities) if j != i)
                dV[i, p] = -A*term1 - B*term2 - C*term3
        V = sigmoid(V + dV * 0.001)

        e = (A/2)*np.sum((np.sum(V, axis=1)-1)**2) + \
            (B/2)*np.sum((np.sum(V, axis=0)-1)**2)
        energy.append(e)

    tour = np.argmax(V, axis=0)
    tour_length = sum(D[tour[i], tour[(i+1) % num_cities]] for i in range(num_cities))

    plt.figure(figsize=(6, 3))
    plt.subplot(1, 2, 1)
    plt.plot(energy)
    plt.title("Energy Convergence - TSP (10 Cities)")
    plt.xlabel("Iteration")
    plt.ylabel("Energy")
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.imshow(V, cmap='plasma')
    plt.title("Final Activation Matrix")
    plt.colorbar(label="Activation")
    plt.tight_layout()
    plt.savefig("lab6_results/Q3_tsp.png")
    plt.close()

    return tour, tour_length

# ------------------------------------------------
# PDF REPORT GENERATOR
# ------------------------------------------------
def generate_report(acc, flip_fraction, board, tour, tour_length):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", "B", 16)
    pdf.cell(200, 10, "Lab 6: Hopfield Network Experiments", ln=True, align="C")

    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 10, "Learning Objective: To understand the working of Hopfield networks and apply them to combinatorial problems.\n")

    # --- Q1 ---
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "Q1: Error Correcting Capability", ln=True)
    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 10, f"The network stored 5 random 100-bit patterns. A pattern corrupted with {int(flip_fraction*100)}% bit flips was successfully recovered with {acc*100:.2f}% accuracy.\n")
    pdf.image("lab6_results/Q1_energy.png", w=170)

    # --- Q2 ---
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "Q2: Eight-Rook Problem", ln=True)
    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 10, "The Hopfield network minimized the energy of an 8x8 binary configuration to place exactly one rook per row and column. The final stable configuration and energy trajectory are shown below.")
    pdf.image("lab6_results/Q2_rook.png", w=170)

    # --- Q3 ---
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "Q3: TSP (10 Cities)", ln=True)
    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 10, f"The Hopfield-Tank network (100 neurons, ~10,000 weights) was used to approximate a 10-city traveling salesman problem. The final route found was {tour.tolist()} with total distance {tour_length:.2f}.")
    pdf.image("lab6_results/Q3_tsp.png", w=170)

    # --- Conclusions ---
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "Conclusions", ln=True)
    pdf.set_font("Arial", "", 12)
    pdf.multi_cell(0, 10, 
        "1. The Hopfield network demonstrated associative recall and error correction up to 25% corruption.\n"
        "2. The 8-Rook problem was solved by defining appropriate inhibitory weights enforcing one rook per row and column.\n"
        "3. The Hopfield-Tank continuous network approximated the TSP via energy minimization, illustrating its potential for optimization tasks.\n")

    pdf.output("./lab6_results/Lab6_Report.pdf")
    print("\nðŸ“„ Report successfully generated at: lab6_results/Lab6_Report.pdf")

# ------------------------------------------------
# MAIN EXECUTION
# ------------------------------------------------
if __name__ == "__main__":
    print("\nLAB 6: Hopfield Network Experiments (Team : Code Warriors) ===")
    acc, flip_fraction = run_error_correction()
    board = run_eight_rook()
    tour, tour_length = run_tsp()
    generate_report(acc, flip_fraction, board, tour, tour_length)
